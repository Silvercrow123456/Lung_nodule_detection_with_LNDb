# -*- coding: utf-8 -*-
"""creating_labels.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CHUNzFOV_0fXcAlf2relShiQiqfCReY8
"""

### Coordinates annotations
# This functions are used to find the new coordinates of the nodules after the (512,512) resize of the images
def toPercentage(img_orig, x1, y1, x2, y2, xc, yc):
     c, h, w = img_orig.shape
     x1p = x1 / w
     x2p = x2 / w
     y1p = y1 / h
     y2p = y2 / h
     xcp = xc / w
     ycp = yc / h
     return x1p, y1p, x2p, y2p, xcp, ycp

def toImCoord(x1p, y1p, x2p, y2p, xcp, ycp ):
     h,w = (512, 512)
     xmin = x1p * w
     xmax = x2p * w
     ymin = y1p * h
     ymax = y2p * h
     xcenter = xcp * w
     ycenter = ycp * h
     return xmin, xmax, ymin, ymax, xcenter, ycenter
# Absolte coordinates of all nodules regardless their size
def slice_info_wo(mask, slice_props, k):
     y1, x1, y2, x2 = slice_props[k].bbox #x1 is xmin; x2 is xmax
     yc_k, xc_k = slice_props[k].centroid

     x1p, y1p, x2p, y2p, xcp, ycp = toPercentage(mask, x1, y1, x2, y2, xc_k, yc_k)
     xmin, xmax, ymin, ymax, xcenter, ycenter = toImCoord(x1p, y1p, x2p, y2p, xcp, ycp)

     bh_k = ymax - ymin
     bw_k = xmax - xmin

     return xcenter, ycenter, bw_k, bh_k
# Relative to the image size coordinates - yolo compatible
def slice_info_rel_wo(mask, slice_props, k):
     y1, x1, y2, x2 = slice_props[k].bbox #x1 is xmin; x2 is xmax
     yc_k, xc_k = slice_props[k].centroid

     x1p, y1p, x2p, y2p, xcp, ycp = toPercentage(mask, x1, y1, x2, y2, xc_k, yc_k)
     xmin, xmax, ymin, ymax, xcenter, ycenter = toImCoord(x1p, y1p, x2p, y2p, xcp, ycp)

     bh_k = ymax - ymin
     bw_k = xmax - xmin

     return xcp, ycp, bw_k/512, bh_k/512
# Dictionary with all nodules' coordinates as values and the file name as a key
dic_wo = defaultdict(dict)
dic_rel_wo = defaultdict(dict)
for mask_file in glob.glob('/content/gdrive/MyDrive/training_data_lung_nodule/mask/*.mhd'):
     mask, spacing, origin, transfmat = readMhd(mask_file)

     props = regionprops(mask, intensity_image=None, cache=False, coordinates=None)

     for i in range(len(props)):
         labels = props[i].label
         zc, yc, xc = props[i].centroid

         slice_props = regionprops(mask[int(zc)][:][:]) # check if there is another nodule on the first nodule's center slice

         file = mask_file.split('/')[-1].split('_')[0]
         #print(fille)
         rad = mask_file.split('_')[-1].split('.')[0]
         #print(rad)
         #print(labels)
         dic_wo[str(f'{file}_finding{labels}_{rad}'.format(file,labels,rad))]={k+1: slice_info_wo(mask, slice_props, k) for k in range (len(slice_props))}
         dic_rel_wo[str(f'{file}_finding{labels}_{rad}'.format(file,labels,rad))]={k+1: slice_info_rel_wo(mask, slice_props, k) for k in range (len(slice_props))}

#### YOLO compatible .txt files with relative nodule coordinates
for k2, v2 in dic_rel_wo.items():
     if k2 in confirm_pos and v2[1] != None:
         f= open(k2  + ".txt", "w")
         for k, v in v2.items():
             if k == 1 and v != None:
                 f.write(f"{0} {v[0]} {v[1]} {v[2]} {v[3]}")
             if k > 1 and v != None:
                 f.write(f"\n{0} {v[0]} {v[1]} {v[2]} {v[3]}")
         f.close()
for k2, v2 in dic_rel_wo.items():
     if k2 in confirm_neg and v2[1] != None:
         f= open(k2  + ".txt", "w")
         for k, v in v2.items():
             if k == 1 and v != None:
                 f.write(f"{1} {v[0]} {v[1]} {v[2]} {v[3]}")
             if k > 1 and v != None:
                 f.write(f"\n{1} {v[0]} {v[1]} {v[2]} {v[3]}")
         f.close()